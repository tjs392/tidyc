cvm bytecode notes

how it works:
- take the ast and convert to bytecode instructions
- each function gets virtual registers (r0, r1, r2, etc)
- during codegen track which registers are in use and reuse them when variables die
- instructions are fixed 32-bit like lua

instruction format:
- 32 bits total

- iABC format: [6-bit opcode][8-bit A][9-bit B][9-bit C]
  - for three operand instructions (arithmetic, comparisons, moves)

- iABx format: [6-bit opcode][8-bit A][18-bit Bx]
  - for instructions with one register and a large immediate/index

- iAsBx format: [6-bit opcode][8-bit unused][18-bit sBx (signed)]
  - for jump instructions with signed offset

- max 256 registers per function (8 bits)

instructions:

iABC (arithmetic and move)
- ADD rA, rB, rC
- SUB rA, rB, rC
- MUL rA, rB, rC
- DIV rA, rB, rC
- MOD rA, rB, rC
- MOV rA, rB, -

iABC (comparisons - store result as 0 or 1)
- EQ rA, rB, rC  --> rA = (rB == rC) ? 1 : 0
- LT rA, rB, rC  --> rA = (rB < rC) ? 1 : 0
- LE rA, rB, rC  --> rA = (rB <= rC) ? 1 : 0

iABx
- LOADK rA, Kx -> load constant from constant table at index Kx into rA
- TEST rA -> check if rA is true (nonzero)

iAsBx (control flow)
- JMP sBx -> jump by signed offset sBx instructions

control flow pattern:
- for "if (x < 5) { body }"
  1. LT r1, r0, r5         // r1 = (x < 5)
  2. TEST r1               // test r1
  3. JMP +skip             // if false, jump over body, skip is an offset
  4. [body instructions]
  5. skip:

constant table:
- each function has a constant table (vec of values)
- stores int literals, float literals, strings, etc
- LOADK references by index
- built during codegen

example codegen:
- for expression like 5 + y
- emit LOADK r0, K0 (where constants[0] = 5)
- load y from symbol table (say it's in r1)
- emit ADD r2, r0, r1
- result in r2